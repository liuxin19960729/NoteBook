# 5 进程管理
## 5.1 程序,进程和线程
```
进程:正在运行的程序
   1.二进制镜像加载到内存中
   2.虚拟内存实例
   3.内核资源(打开的文件,上下文,用户关联,线程)



note：
  单线程的进程中,进程就是线程
  一个进程只有一个虚拟内存实例
  一个进程多个线程,多个线程共享虚拟内存实例
```
## 5.2 进程ID
```
空闲进程(idle process)
    没有其他进程运行,内核运行(内核pid值为0)


init 进程
    pid =1 
    一般来时 Linux 启动运行的第一个进程是 init 进程




init 进程 用户可以自定义指定
or 内核会尝试执行 
    /sbin/init
    /etc/init
    /bin/init 
    /bin/sh 内核没有找到上面的的三个程序就会运行 /bin/sh



note:
   若内核没有找到 上面的4个程序,就会报警并且 挂起






kernel -->寻找 init 程序 --> 执行 init 程序 ,kernel 交出执行权限 -->
init 系统初始化 系统各种服务启动 登录进程执行


```
### 5.2.1 分配进程ID
```
为了和老UNIX系统兼容(16bits)，内核进程最大值为32768
note:
   系统管理员可以 修改 /proc/sys/kernel/pid_max  值
   改变进程最大值,但是可能会失去兼容性


pid 值 会线性增长 即使 前面值有进程已经不存在了,直到达到最大值,
才会用前面哪些销毁进程pid 值

note:
    上面这种方式会保证在短时间pid 是稳定且唯一的
```
## 5.2.2 进程体系
```
除了 init 以外,每个进程都是由其他进程创建

每个进程都属于每个用户和用户组
  /etc/passwd
  /etc/group


note:
  每个进程都继承了父进程的 uid 和 gid



进程组(process group):
    子进程和父进程那个进程组

```
### 5.2.3 pid_t
```c
#include <sys/types.h>

note:
  在Linux 中 pid_t 通常定义为c语言的int 类型
```
### 5.2.4 获取进程ID和父进程ID
```c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
 

pid_t getppid(void);


note:
    上面的两个函数总是消失



(intmax_t) getpid()
(intmax_t) getppid()


intmax_t C/C++ 类型
确保可以存储系统上任意有符号的整数值

print %jd 可以修饰 intmax_t 类型


note:
   如果你使用的该系统没有intmax_t 可以任务 pid_t 就是 int 类型


```
