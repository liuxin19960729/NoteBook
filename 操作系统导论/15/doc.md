# 15 地址转换
```
基于硬件的的地址转换称为地址转换
硬件的地址转换会对每次内存访问进(指令读,数据的读写)行处理
   访问内存使用的虚拟内存底子 转换为物理内存地址
   OS 必须要在关键时候接入设置好这些硬件的参数,使程序能够正确的访问
   OS 必须管理好内存,知道那些物理地址空闲,知道那些物理地址正在使用
```
## 15.1 假设
## 15.2 一个例子
## 15.3 动态(基于硬件) 重定位
```
基地址寄存器
硬件通过进程的虚拟地址 转换为 物理地址值 在去加载 获取 设置
地址的重定
   进程在运行时候物理地址改变,重置设置映射地址

界限寄存器:(保护进程内存区域的界限)
   当访问地址超过设置的界限或地址值为负数,CPU 会触发异常

基地址寄存器配合解限寄存器是存在每个CPU内部的
MMU(Memory Management Unit): 负责地址转换的部分统称为内存管理单元
```
**转换示例**
```
程序被加载到物理地址16kb 上


基地址+ 虚拟地址

虚拟地址   物理地址
0          16kb
1kb        17kb
......
```
## 15.4 硬件支持:总结
```
需要支持两种模式
OS
  特权模式
普通应用程序
   用户模式


需要再一些特殊时刻CPU 切换模式
   系统调用
   异常
   中断
   .......



动态重定位：
  1.特权模式
  2.基地址寄存器+界限寄存器
  3.检查访问地址是否越界
  3.OS 指定用户程序的基地址寄存器+ 和界限寄存器
  5.注册异常处理函数
  6.用于进程访问越界触发异常
```
## 15.5 操作系统的问题
```
动态重定位:操作系统的职责

1.内存管理
   未新进程分配内存
   回收终止进程的内存
   通过空闲列表(free list) 来管理内存

2.基址/界限管理
   必须在上斜纹切换的时候正确的设置基址和界限寄存器

3.异常处理
   当发生异常的时候执行该代码






1.OS  启动
  初始化陷阱表(处理中段的函数)

2.硬件 记录下每个终端对应的函数指针
   系统调用处理程序地址
   时钟处理程序
   非法内存处理程序
   非法指令处理程序   

3. OS 
   开始中断时钟
4.硬件
   时钟中断在 x ms 后触发中断

5.OS
  初始化进程表
  初始化空闲列表

6.
   OS:
      kernel 运行 
```