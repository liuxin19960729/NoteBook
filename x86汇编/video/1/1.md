## 8086 通用寄存器
```
1.INTEL 8086 有哪几个通用寄存器?长度是多少?
AX BX CX DX SI DI SP BP  -- 16 bits =2 byte =1 word

2.上面的通用寄存器有哪些可以分为两个8 bits 寄存器,这些8btis 叫什么名字?
AX   AH AL 
BX   BH BL
CX   CH CL
DX   DH DL



3.向DH写入0x08,向DL写入0x3C,则DX 值是多少?

DH 0x08  DL 0X3C
AX 0x83C

```

## 8086 访问内存和访问内存的字节序
```
1.寄存器的内容是0x55AA,将它写入内存时，占用的地址是0008，低字节序(小端),那么写入后瞻仰红几个内存单元?他们的地址分别是多少?他们的内容是什么?



地址        内容
0x0009      0x55
0x0008      0xAA

```

## 程序的分段
## 程序的重定位的难题
```
IPR:始终是下一条将要执行的指令的地址

IPR -> 地址线 -> 从内存(IPR 指令地址指针)取出内容(0xA1 00 0C) -> 执行取出的内容
 -> 执行指令时将0x0c00的地址对应的数据防到AX -> IPR 地址更新(cur address + cur instructions length)
->通过IPR 地址放入到地址线去除下一条指令 ......
```
## 数据段寄存器来解决程序的重定位问题
```
数据段寄存器:DSR  (数据段开始的物理地址)

DSR+偏移地址=数据的物理地址
```
## 内存访问的困境
```
8086 16根数据线
     一次访问2byte=1word


     20根地址线
        2^20=1048576 byte = 2024 kb =1m 只能访问到1m的数据
        


内存访问寄存器
DS 数据段寄存器 - 数据段起始物理地址
CS 代码段寄存器 - 代码段起始物理地址

DS CS 16 bits 寄存器

```
## 8086 选择段地址的策略
```

20根地址线

内存访问寄存器
DS 数据段寄存器 - 数据段起始物理地址
CS 代码段寄存器 - 代码段起始物理地址
DS CS 16 bits 寄存器


note:
  必须以0 结尾的地址才能地址才能作为段地址(地址线20根最多传输地址20bits)

  例如:下面这种才能作为段寄存器的值存入
    0x30ce0
    0x33ce0
    0x00000 



0x33ce0 ->cs=0x33ce .....


段寄存器访问地址
CS  DS
0x33ce  *16 ==0x33ce0  还原成原物理地址
```
## 8086 内存访问过程
```
IP : 指令指针寄存器 保存指令的偏移地址
CS =address >> 4 存入到 代码段寄存器
DS =address >> 4 存入到 数据段寄存器

IP :第一条指令的偏移地址赋值

1.物理地址 CS<<4+IP =address(物理地址)
2.取出指令 译码  访问需要使用到的内存数据(DS<<4+偏移地址)
3.IP 的值(下一条指令偏移值) =IP 值 + 执行指令的长度
```
## 逻辑地址和分段的灵活性
```
0x22567 物理地址
0x22567>>4=0x2256 or 0x2255 ... 段寄存器的值
 
逻辑地址 2256:x1  2255:x2

note: 
  在8086系统中,逻辑偏移地址最大只能是0xFFFF,

  逻辑段 宽度 :[0,0xFFFF] = 65536 byte =64kb
     



1.如果一个内存单元的逻辑地址是B800:0028,那么这个单元的物理地址是多少?
0xB800<<4+0X0028==0XB8028;

2.如果一个内存单元的物理地址是B0375,那么将它表示成3种不同的逻辑地址
0xB037:0x0005
0xB036:0x0015
0xB035:0x0025



3.8086处理器可以访问1M内存,在不浪费任何空间切不允许重叠的情况下,这1M可以划分为多少个16字节的段,可以划分为多少个64kb的段?

端只能是0结尾的地址
例如 0x00010 和 0x00000 相差16 byte 
1M 有 1024576 byte 所以   1024576/16== 65536 ,1M可以划分为 65536 个 16字节大小的段




```

