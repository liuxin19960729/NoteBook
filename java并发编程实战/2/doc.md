# 线程的安全性
```
一个线程是否要安全取决于它是否被多个线程访问,如果访问对象存在多个线程,需要采用同步机制来协同对象的可变状态的访问

Java 中的同步机制
    synchronized
    volatile
    显示锁
    原子变量



三种方式可以使数据状态在多线程中安全
1.不在线程中共享变量
2.将状态设置为不可变
3.在访问状态变量的时候使用同步

只有在类中包含了多个线程需要访问的状态,线程安全类才是有意义的

```
## 2.1什么是线程安全性
```
线程安全性,最核心的概念就是正确性。


线程安全类：
  不敢运行时采用什么调度方式,线程如何交替执行,在主代码使用该类不需要任何同步和协同，这个类都能表现出正确的行为


线程安全类中封装了必要的同步机制,因此客户端无需进一步采取同步措施。
```
### 一个无状态的Servlet
```
无状态的对象一定是线程安全的
```
## 2.2 原子性
```
无状态程序 毫无疑问就是状态安全的

假设
  增加一个计数器 long counter (状态)


++count
包含3个步骤
    1.读取count值
    2.将count + 存在临时变量中
    3.将临时变量数据存入count


```
### 2.2.1 竞争条件
### 2.22.2 示例:延迟初始化中的竞态条件
```java


public class ThreadSafeInstance {

	private static ThreadSafeInstance _instance;

	public static ThreadSafeInstance Instance() {

		if (Objects.isNull(_instance)) {
			_instance = new ThreadSafeInstance();
		}

		return _instance;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}


_instance 每个线程都能共享，存在线程之间的竞争


A:线程
  _instance = new ThreadSafeInstance();
  1.多长时间初始化对象
  2.何时将引用给_instance


B:线程
    Objects.isNull(_instance)
    1.判断为null 的时候 可能 A 正在初始化对象


```
### 2.2.3 复合操作
```
避免竞争:
  在某个线程修改变量的时候,通过某种方式,防止其他线程使用这个变量。
  确保其他线程只有在当前线程修改完后再读取和修改该变量的状态

```
## 2.3 加锁机制
### 2.3.1内置锁
```java
sychronized (lock){

}


当前对象
public synchronized void syn1() { 加锁进入该方法

}退出该方法释放锁

Class 独享
public synchronized static void name() {加锁进入该方法

}退出该方法释放锁

上面的方式获取锁后无论正常退出代码块和异常退出代码块都会释放锁



竞争到锁的线程进入代码块,没有竞争到代码块的线程会阻塞到那里,直到
获取锁的线程释放锁,阻塞的线程重新去竞争锁


```


### 2.3.2 重入
```java
内置锁可重入
   解释:
     某个线程试图获的一个已经由它自己持有的锁,那么请求就能获得成功

"重入"可以知道获取锁的操作粒度是线程,而不是调用



重入的一种实现方式:
    锁信息:
        线程持有 id
        计数器
    
    计数器为0 表示没有现成获取该锁
    
  
  1.  线程请求未被线程获取的锁
       JVM 记录线程ID
       JVM 将计数器+1 变为1
 


note:
    如果锁是不可以重入的则 

 	public synchronized void syn1() {

		syn2();
	}

	public synchronized void syn2() {

	}

     syn1()-->call syn2() 由于锁的对象都是 this
     则 会阻塞等待 this 释放,由于syn1()还没有执行完,则不会释放,这样就造成了死锁   


```

## 2.4用锁来保护状态
```
常见的加锁约定:
    1.将所有可变的状态都封装在对象内部。
      内置锁对所有访问可变的状态代码进行同步

    为什么需要每个对象有一个内置锁?
        避免显示的创建锁
        





并非所有的数据都需要保护
  1.只有被多个线程同时访问的可变数据才应该通过锁来保护
  2.对于每个包含多个变量的不变形条件,其中涉及的所有变量都由同一个锁来保护

```
## 活跃性和性能
```
1.通过缩小同步代码块的范围,既保护程序的安全性,由维持程序的并发性
   尽量将不影响同步代码块的结果,又耗时的操作从同步代码块分离出去。
   可将耗时获得的结果不用直接设置到对象属性上,先设置到函数local 变量上(此时应该释放锁),
   当需要设置到对象上的时候在重新去获取锁   




note:
    1.简单和性能之间存在相互制约的因素,不要为了实现某个同步策略而一味的去，追求性能,而牺牲了简单性
    2.无论计算密集型或IO密集型操作,如果一个接口卡无法接口无法快速的返回结果 都不要持有锁区进行这些耗时的操作
```